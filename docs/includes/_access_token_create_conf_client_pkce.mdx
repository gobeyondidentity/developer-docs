In this flow, you call the app's '/authorize' endpoint, initiating a browser based flow where the user provides their credentials in exchange for a code. 
In a second API call to the '/token' endpoint, you then exchange the code for an access token. 
You authenticate the call to the '/token' endpoint with the app's credentials.  

Note that you will need an identity configured with the [ability to authorize the scopes](/docs/next/api-scopes#scopes-authorized-for-the-identity-approving-the-authorization-request) your app is requesting.   

1. Create an [app](/docs/next/add-an-application) with the following properties:  

  | Parameter | Value|
  |---|---|  
  |Protocol|OIDC|  
  |Client Type|Confidential|
  |PKCE|S256|
  |Token Endpoint Auth Method|Client Secret Basic|
  |Grant Type|Authorization Code|
  |Configuration Type (on Authenticator Config tab)|Hosted Web|  

  Fill in a **Display Name** and at least one **Redirect URI**, then click **Submit** to save the app.  

2. Create your '/authorize' request  

  Create the HTTP request with the following properties:  

  **Request method:** GET  
 
  **Request url:**  

  ```plaintext
  https://auth-{us|eu}.beyondidentity.com/v1/tenants/{tenant_id}/realms/{realm_id}/applications/{application_id}/authorize?response_type=code&client_id={client_id}&redirect_uri={redirect_uri}&scope={scopes}&state={state}&code_challenge={codeChallenge}&code_challenge_method=S256
  ```
  
  where:  
 
   - {client_id} is your app's **Client ID**  

   - {redirect_uri} is one of the app's configured **Redirect URI** values  

   - {scopes} is 'openid' plus one or more of the app's **Allowed Scopes**, space delimited  

   - {state} is a value generated by your app to maintain state betewen the request and response  

   - {codeChallenge} is generated as defined in [RFC 7636](https://datatracker.ietf.org/doc/html/rfc7636#section-4.2), example JavaScript snippet below:  

   ```javascript
    codeVerifier = crypto.randomBytes(32).toString('base64url');
    codeChallenge = crypto.createHash('sha256').update(codeVerifier).digest().toString('base64url');
   ```

3. Consume the '/authorize' response and authorization code  

  In response to the '/authorize' request, Beyond Identity redirects to the app's configured authentication url. 
  In this example, the authenticator configuration type is "Hosted Web", so the authentication url is hosted by Beyond Identity (see [Authenticator Configurations](/docs/next/authentication)).  

  :::info important  
  Please note that the redirection must be handled in the front end (such as React, Angular, or vanilla JavaScript running in the user's browser) in order for passkey authentication to work.  
  :::  

  Once passkey based authentication is complete, Beyond Identity will redirect back to the app's configued redirect URI with a 'code' parameter in the query string.  You will use this code in the '/token' request.  

1. Create your '/token' request  

  Create the HTTP request with the following properties:  

  **Request url:**  

  ```plaintext
  https://auth-{us|eu}.beyondidentity.com/v1/tenants/{tenant_id}/realms/{realm_id}/applications/{application_id}/token
  ```

  **Request method:** POST  

  **Request headers:**  

  ```plaintext
  Authorization: Basic {client_credentials}
  content-type: application/x-www-form-urlencoded  
  ```

  where {client_credentials} is the base64 encoded value of your app's **Client ID** and **Client Secret**, concatenated together in the format '{client_id}:{client_secret}' 

  **Request body:**  

  ```plaintext
  grant_type: "authorization_code"
  code: {authorization_code}
  client_id: {client_id}
  redirect_uri: {redirect_uri}
  code_verifier=${codeVerifier}
  expiration_time: {seconds}
  custom_claims: {custom_claims_json}
  ```

  where:  

   - {authorization_code} is the code returned from the '/authorize' call  

   - {client_id} is the app's configured **Client ID**  

   - {redirect_uri} is one of the app's configured **Redirect URI** values and matches the redirect_uri sent in the '/authorize' call  

   - {codeVerifier} is defined as in [RFC 7636](https://datatracker.ietf.org/doc/html/rfc7636#section-4.1), example JavaScript snippet below:  

   ```javascript
    codeVerifier = crypto.randomBytes(32).toString('base64url');
    codeChallenge = crypto.createHash('sha256').update(codeVerifier).digest().toString('base64url');
   ```
  
   - expiration_time is an OPTIONAL parameter, and {seconds} is the desired time after minting, in seconds, for which the token will be considered valid. If included, this value must be less than or equal to the app's configured **Expires** setting  

   - custom_claims is an OPTIONAL parameter, and {custom_claims_json} is a JSON string containing the desired additional claims as key value pairs, for example '{"a": "b", "c": "d"}'. Upon successful token request, the resulting token will contain additional field 'bi_custom' with the desired claims.

